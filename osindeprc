#!/bin/bash

DEBUG=1 #0 true, 1 false
PLATFORM=$(uname)
####
#HELPER FUNCTIONS
####
inPath() { 
#returns 0 if true, else 1
    #Create array from Path
    local tmpPaths=( $(echo $PATH|tr ':' ' ') )
    #echo $tmpPaths
    local occurences=0
    for i in ${tmpPaths[@]}; do
        if [[ $1 = $i ]]; then 
			occurences=$((occurences+1)) 
		fi
        if [[ $occurences -ne 0 ]]; then 
			ret=0; break ; 
		fi
    done
    
    [[ $ret -eq 0 ]] && echo $ret || echo 1
};

removeDoublettesInPath() { export PATH=$(echo $PATH|tr ':' '\n'|uniq|tr '\n' ':') ; }

setVariable() {
    #USAGE Expl. f. setVariable $1 $2 $3
    #setVariable WINEDEBUG "warn-all" wine //$3 is supplied so so it will be checked for
    #via ${3:-${2}} #NOTE: ${var:-x} substitutes x for var if var unset OR empty.
    #USAGE Expl. f. setVariable $1 $2
    #setVariable EDITOR vi //$3 does not exist so it will be checked for $2
    which ${3:-${2}} &>/dev/null
    [[ $? -eq 0 ]] \
    && export ${1}=${2} \
    || { [[ $DEBUG -eq 0 ]] && echo "Problem with export ${1}=${2}\n${3:${2}} not installed" ; }
    
} ;

#USAGE EXAMPLE:
#setPath /opt/local/bin/port /opt/local/bin:/opt/local/sbin
# => [[ -d /opt/local/bin/port ]] && export /opt/local/...:$PATH
setPath() { [ -d $1 ] && export PATH=$2:$PATH ; };

setAlias() { 
    [[ -x ${3:-$2} ]] || [[ $(which ${3:-$2}) ]] \
    && alias $1="$2" \
    || { [[ $DEBUG -eq 0 ]] && echo "$2 is not installed" ; } 
};

setEvals() {
    for i in $@;do
        eval $i
    done
};

#Map-Function. Usage example: map func2apply array on whose elements to apply func on.
map() {
    for i in ${@:2}; do
       $1 $(echo $i|tr '@' ' ')
    done    
}


####
#OS INDEPENDENT STUFF
####
[ -e $HOME/.env ] && {
    #VARIABLES DEPENDING ON COMMANDS BEING PRESENT
    #Made conditional because of reliance on variables declared in $HOME/.env
    . $HOME/.env ;
    setVariable WINEDEBUG "warn-all,relay-all,err-all" wine ;
    #setVariable EDITOR $EDITOR
    #setVariable VISUAL $VISUAL
} #|| echo "$HOME/.env does not exist. Is this intended?" ;

# set PATH so it includes user's private bin if it exists.
#NOTE: inPath is required since it seems to be set from somewhere else on some systems.
[[ -d "$HOME/bin" ]] && [[ ! $(inPath "$HOME/bin") -eq 0 ]] && PATH="$HOME/bin:$PATH" 


###PLOWING A PATH TO THE BINS
    case $PLATFORM in
        "Darwin") 
            [ -e $HOME/.env-mac ] \
            && {
                source $HOME/.env-mac 
                map setPath $macPaths
                map setAlias $macAliases
                map setVariable $macVariables
            } #|| echo "$HOME/.env-mac does not exist. is this intended?" 1&>2
            ;;
        "Linux")
            [ -e $HOME/.env-linux ] \
            && {
                source $HOME/.env-linux
                map setAlias $linuxAliases
                map setPath $linuxPaths
                map setVariable $linuxVariables
                removeDoublettesInPath
            }
            ;;
        "FreeBSD")
            #setALIASES $freebsdAliases
            setEvals $freebsdEvals
            ;;
    esac

    [[ -e $HOME/.functionsrc ]] && source $HOME/.functionsrc

####
#STUFF TO COMPLEX TO PROCESS IN BATCH. I.E. CUSTOM FUNCTIONS
####

#if [ ! -S ~/.ssh/ssh_auth_sock ]; then
#  eval `ssh-agent`
#  ln -sf "$SSH_AUTH_SOCK" ~/.ssh/ssh_auth_sock
#  ssh-add ~/.ssh/id_rsa
#fi
#export SSH_AUTH_SOCK=~/.ssh/ssh_auth_sock
#ssh-add -l > /dev/null || ssh-add


[ -e $HOME/.zpool.sh ] && source $HOME/.zpool.sh
